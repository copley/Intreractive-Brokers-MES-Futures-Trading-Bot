Simple Scalp Bot – Requirements Specification
===============================================

1. System Overview
-------------------
**Purpose:**
  • Analyze live market data for futures (e.g., MES, XINA50) on short time frames.
  • Identify short-term (scalp) trading opportunities using momentum, volume, and volatility indicators.
  • Log or simulate trades based on entry/exit conditions (paper trading in this version).
  • Enforce a single active trade at a time.

**Scope:**
  • Real-time data subscription via Interactive Brokers’ TWS API.
  • Aggregation of tick-by-tick data into configurable bars (e.g., 15s, 30s, or 1-minute).
  • Calculation of key technical indicators (EMA, RSI, ATR, VWAP, Relative Volume).
  • Trade signal generation, trade logging (including partial fills), and performance summary.
  • Future expansion to live order execution (using bracket orders, OCA groups, etc.).


2. System Architecture & File Structure
-----------------------------------------
The project is organized into the following modules:

  my_scalp_bot/
    ├── config.yaml                   # Central configuration (IB credentials, bar length, indicator params, contract details, risk settings, logging)
    ├── connection/
    │     ├── contract_definition.py  # Encapsulates contract details (e.g., MES, XINA50)
    │     └── ib_connection.py        # Manages IB connection, callbacks, and reconnection logic
    ├── data/
    │     ├── data_loader.py          # (Optional) Load historical data for backtesting
    │     └── data_preprocessor.py    # (Optional) Data cleaning/preprocessing
    ├── execution/
    │     ├── limit_order_execution_logic.py
    │     ├── long_order_execution_logic.py
    │     ├── short_order_execution_logic.py
    │     ├── stop_loss_order_execution_logic.py
    │     └── trade_execution_logic.py  # Orchestrates simulated order placement
    ├── indicators/
    │     ├── indicator_logic_EMA.py   # Computes EMA(9) & EMA(21) and crossover signals
    │     ├── indicator_logic_RSI.py   # Computes RSI(9)
    │     ├── indicator_logic_ATR.py   # Computes ATR(9)
    │     ├── indicator_logic_VWAP.py  # Computes VWAP and optionally includes volume logic
    │     └── ...  
    ├── managers/
    │     ├── dynamic_stop_loss.py     # Provides ATR-based/trailing stop adjustments
    │     ├── entry_manager.py         # Checks entry signals for long/short trades
    │     ├── exit_manager.py          # Checks stop-loss and take-profit exit conditions
    │     ├── stop_loss_manager.py     # Updates stop-loss levels during a trade
    │     ├── take_profit_manager.py   # Updates take-profit levels (if trailing logic is used)
    │     └── trade_manager.py         # Coordinates trade lifecycle, partial fills, and logging
    ├── utils/
    │     └── helpers.py              # Utility functions (timestamp formatting, math, etc.)
    ├── aggregator.py                 # Aggregates raw trades into time-based bars
    ├── list_files.py                 # (Utility) Lists or manages file directories/logs
    ├── main.py                       # Entry point: loads config, connects to IB, starts aggregator, and processes signals
    └── trade_record.text             # Log file for each trade and partial fill details


3. Functional Requirements
----------------------------
• **Data Acquisition & Aggregation:**
  - Subscribe to tick-by-tick data from IB.
  - Aggregate incoming trades into bars of configurable length (15s, 30s, 1m).

• **Indicator Calculations (per bar):**
  - Compute EMA (9 & 21) and detect crossovers.
  - Calculate RSI (9) for momentum.
  - Compute ATR (9) for volatility-based stop sizing.
  - (Optionally) Compute VWAP and Relative Volume (RVOL).

• **Trade Signal Generation:**
  - **Bullish (Long) Entry:**
      - EMA(9) > EMA(21) on the just-closed bar.
      - Price closes above VWAP.
      - RSI(9) > 50.
      - RVOL exceeds a configured threshold (e.g., > 1.5).
  - **Bearish (Short) Entry:**
      - Mirror logic for EMA crossover and confirmation (if enabled).

• **Trade Management:**
  - Allow only one active trade at a time (including partial fills).
  - For each new “paper” trade, log:
      - Entry time, price, size, and indicator values.
      - ATR-based stop-loss (e.g., Entry – 1.5×ATR) and fixed take-profit (e.g., Entry + 3 points).
  - Monitor active trades; on bar updates, check if current price triggers stop-loss or take-profit.
  - Log partial fills and the final trade P/L when a trade is closed.

• **Event Handling & Concurrency:**
  - Use IB’s tickByTickAllLast callback to process live trade data.
  - Run the IB message loop in a background thread.
  - (Future enhancement) Add multi-threading or a queue-based system to separate aggregation from indicator computations and logging.

• **Error Recovery & Reconnection:**
  - Detect disconnections (via IB error callbacks) and attempt automatic reconnection.
  - Fill data gaps by optionally loading historical data if needed.

• **Logging & Reporting:**
  - Maintain a persistent log (trade_record.text) for each trade entry, partial fills, and exit.
  - Produce summary performance metrics (total trades, net P/L, win/loss ratio, drawdown, etc.) at the end of the trading session.


4. Non-Functional Requirements
-------------------------------
• **Reliability:**
  - Ensure logs are preserved in case of abrupt shutdown (e.g., Ctrl+C).
  - Implement reconnection logic for IB connectivity issues.

• **Maintainability:**
  - Follow a modular file/folder structure to simplify updating or replacing individual components (e.g., adding a new indicator).
  - Use a centralized configuration file (config.yaml) for all user-defined parameters.

• **Performance:**
  - Efficient aggregation and indicator calculations to support short bar intervals.
  - Adhere to IB rate limits by minimizing unnecessary data requests.

• **Security:**
  - Secure storage and handling of IB credentials (mask or encrypt sensitive information).
  - Use encrypted connections where possible with TWS/Gateway.


5. Environment & Dependencies
-----------------------------
• **Programming Language:**
  - Python 3.x

• **External Libraries:**
  - **ibapi**         – For Interactive Brokers API integration.
  - **PyYAML**        – For loading configuration from YAML files.
  - **pandas**        – For data manipulation and indicator calculations.

  (Additional built-in libraries used include: threading, time, datetime, os, math)

  
6. Configuration (config.yaml)
-------------------------------
The central configuration file should include:
  - IB connection settings (host, port, clientId)
  - Bar length (in seconds)
  - Indicator parameters (periods for EMA, RSI, ATR, use_vwap flag)
  - Contract specifications (symbol, exchange, currency, contract month, etc.)
  - Risk management settings (scalp target in points, ATR stop multiplier, single_trade_mode flag)
  - Logging file path (e.g., trade_record.text)


7. Core Trade Entry & Exit Logic
----------------------------------
• **Calibration:**
  - Wait for a sufficient number of bars (e.g., 21) before generating signals.

• **Entry Conditions:**
  - **Long Trade:**
      - EMA(9) > EMA(21) confirmed on a finalized bar.
      - Price above VWAP.
      - RSI(9) > 50 and RVOL exceeds threshold.
      - If conditions are met and no trade is active, log a long entry at the bar’s close.
  - **Short Trade:**
      - (Optional) Use mirrored conditions for a short entry.

• **Stop-Loss & Take-Profit:**
  - Set stop-loss using an ATR-based calculation (e.g., Entry – 1.5×ATR).
  - Set a fixed take-profit target (e.g., Entry + 3 points).
  - Monitor price updates; if the current price reaches either level, close the trade and log the outcome.

• **Partial Fills:**
  - Simulate partial fills by logging each fill event (time, price, quantity) under the same trade ID.


8. Future Enhancements
-----------------------
• Transition from paper trading to live order execution using IB’s real order placement API.
• Incorporate advanced concurrency with multi-threading or queue-based processing.
• Integrate machine learning or more advanced statistical techniques for signal refinement.
• Develop a GUI dashboard for real-time trade and performance monitoring.
• Enhance error handling with more robust recovery and reconnection strategies.

9. Final Notes
--------------
This requirements document provides a modular, scalable blueprint for developing a robust scalp bot. It covers live data acquisition, technical indicator computation, trade signal generation, trade lifecycle management, and logging. The design facilitates future upgrades (e.g., real order execution, enhanced concurrency) while emphasizing maintainability and performance.

  
-------------------------------
End of Requirements Specification
